---
title: 闭包
tags: 面经
categories: Code
abbrlink: 32272
date: 2021-06-11 00:00:00
---

参考：[阮一峰的网络日志-什么是 JS 闭包](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html?fileGuid=hq6gGYhQxrwrqydC)

- 要了解闭包，首先需要理解 JS 作用域，在 JS 中，函数内部可以访问全局变量，外部当然无法访问函数内部变量，但是，我们有时候需要得到函数内的局部变量
- 但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现，那就是：在函数的内部，再定义一个函数
<!-- more -->

```javascript
function f1() {
  var n = 999;
  function f2() {
    alert(n); // 999
  }
}
```

- 函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。
- 这就是 Javascript 语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。
- 所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
  > 那么现在，既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们就可以在外部读取 f1 内部变量了！

```javascript
function f1() {
  var n = 999;
  function f2() {
    alert(n);
  }
  return f2;
}
var result = f1();
result(); // 999
```

f2 函数，就是闭包，它是定义在一个函数内部的函数，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。因此--

# **闭包就是能够读取其他函数内部变量的函数**

# **闭包的两大应用**

- 上述的可以读取函数内部的变量
- 让这些变量的值始终保持在内存中。

怎么来理解这句话呢？请看下面的代码。

```javascript
function f1() {
  var n = 999;
  nAdd = function () {
    n += 1;
  };
  function f2() {
    alert(n);
  }
  return f2;
}
var result = f1();
result(); // 999
nAdd();
result(); // 1000
```

- 在这段代码中，result 实际上就是闭包 f2 函数。它一共运行了两次，第一次的值是 999，第二次的值是 1000。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。
- 为什么会这样呢？原因就在于**f1 是 f2 的父函数**，**而 f2 被赋给了一个全局变量**，**这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收**。
- 这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在 nAdd 前面没有使用 var 关键字，因此**nAdd 是一个全局变量**，而不是局部变量。其次，**nAdd 的值**是一个**匿名函数**（anonymous function），而这个**匿名函数本身也是一个闭包**，所以**nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。**

#

# 闭包对页面的影响？使用闭包的注意点

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。
  - 解决方法是，在退出函数之前，将不使用的局部变量全部删除。
- 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
