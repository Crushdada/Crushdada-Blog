---
title: JavaScript内存管理_垃圾回收机制
tags: 面经
categories: Code
abbrlink: 32265
date: 2021-06-04 00:00:00
---


参考文章：[MDN | 内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management?fileGuid=rQvK8QRWkr8ghD8w)

<!-- more -->

- JavaScript 是在**创建\*\***变量**（对象，字符串等）**时自动\***\*进行了\*\***分配内存\*\*，并且在不使用它们时“自动”释放。
- **释放的过程**称为**垃圾回收**。这个“自动”是混乱的根源，并让 JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。

# 分配内存的几种场景

- 通过定义变量分配内存
- 通过**函数调用**分配内存,如--

有些函数调用结果是分配对象内存：

```plain
var d = new Date(); // 分配一个 Date 对象
var e = document.createElement('div'); // 分配一个 DOM 元素
```

有些方法分配新变量或者新对象：

```plain
var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2);
// 新数组有四个元素，是 a 连接 a2 的结果
```

# 使用值

使用值的过程实际上是对分配内存进行读取与写入的操作

# 垃圾回收

**当内存不再需要使用时将其释放，这个过程叫做垃圾回收**

- 多数内存管理的问题都在这个阶段。我们无法写出一种完美的垃圾回收算法来保证一块内存确实不被需要了。所以这往往要求开发人员来确定
- 高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程。

## 引用

垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，**一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象**。

例如，一个 Javascript 对象具有对它[原型](https://developer.mozilla.org/en-US/JavaScript/Guide/Inheritance_and_the_prototype_chain?fileGuid=rQvK8QRWkr8ghD8w)的引用（隐式引用）和对它属性的引用（显式引用）。

## 引用计数垃圾收集

**这是最初级的垃圾收集算法**。此算法把“对象是否不再需要”简化定义为“**对象有没有其他对象引用到它**”。如果**没有引用指向该对象**（零引用），**对象将被垃圾回收机制回收**。

## 限制：循环引用

该算法有个限制：**无法处理循环引用的事例**。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，**引用计数算法考虑到它们互相都有至少一次引用**，**所以它们不会被回收。**
